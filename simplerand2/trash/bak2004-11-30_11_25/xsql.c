# include "/user/ingres/files/eqdef.h"
#ifndef	XSQL_C_INCLUDED
#define	XSQL_C_INCLUDED	1
/*===========================================================================*/
/*		ACCESS ROUTINES FOR EMBEDDED OPEN-SQL			*/
/*===========================================================================*/
#include "xdefs.h"
#include "xinclude.h"
#include "xalloc.h"
#include "xalloc.c"
#include "xmessage.c"
#include "xtext.c"
#include "xtime.c"
#include "xpair.c"
#include "xstring.c"
/*---------------------------------------------------------------------------*/
# include "/user/ingres/files/eqsqlca.h"
    extern IISQLCA sqlca;   /* SQL Communications Area */
# include "/user/ingres/files/eqsqlda.h"
#include "xsql.h"
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
static	int	xsql_dyn_null_handler_int	= NO;
static	int	xsql_dyn_null_default_int	= 0;
static	int	xsql_dyn_null_handler_real	= NO;
static	double	xsql_dyn_null_default_real	= 0.0;
static	int	xsql_dyn_null_handler_string	= NO;
static	char	*xsql_dyn_null_default_string	= NULL;
static	int	xsql_dyn_null_handler_datetime	= NO;
static	TIME	xsql_dyn_null_default_datetime;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
static	int	xsql_returnlocaltime		= 1;	/* USE 0 FOR GMT */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
static	int	xsql_error_status		= 0;
static	int	xsql_error_retry		= 0;
static	int	xsql_error_retry_default	= 0;
static	int	xsql_error_loosen		= NO;
static	int	xsql_error_softfail		= NO;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
static	char	*xsql_current_database_name	= NULL;
static	char	*xsql_current_database_options	= NULL;
/*---------------------------------------------------------------------------*/
	/* BIT-FIELD VALUES STORED IN FIRST BYTE OF INGRES DATE FIELD */
#define	XSQL_DATETIME_BIT_EMPTY		0	/* EMPTY DATE (NULL?)	  */
#define	XSQL_DATETIME_BIT_ABSOLUTE	1	/* DATE IS CALENDAR VALUE */
#define	XSQL_DATETIME_BIT_INTERVAL	2	/* DATE IS A DURATION	  */
#define	XSQL_DATETIME_BIT_YEAR		4	/* YEAR VALUE IS PRESENT  */
#define	XSQL_DATETIME_BIT_MONTH		8	/* MONTH VALUE IS PRESENT */
#define	XSQL_DATETIME_BIT_DAY		16	/* DAY VALUE IS PRESENT	  */
#define	XSQL_DATETIME_BIT_TIME		32	/* TIME OF DAY IS PRESENT */
/*---------------------------------------------------------------------------*/
				/* ERROR GENERATED WHILE DATABASE IS OPEN */
static void xsql_error( char *err_msg )
{
	if ( YES == xsql_error_softfail )
		{aside( "Error generated by XSQL\n\"%s\""
			"\nReturning softfail status=%d",
			err_msg, xsql_error_status );
		return;
		}
	inform( "Fatal Error generated by XSQL\n\"%s\"\n\nXSQL Hard-fail EXIT",
		err_msg );
/* # line 60 "xsql.sc" */	/* disconnect */
  {
    IIsqInit(&sqlca);
    IIsqDisconnect();
  }
/* # line 61 "xsql.sc" */	/* host code */
	exit( 0 );
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
				/* ERROR GENERATED WHILE DATABASE IS OPEN */
static xsql_problem( char *err_msg, CLOCK *cl )
{	int	loosen, retry;
	char	*dbname, *dbopt;
	CLOCK	cnow;
	aside( "Error generated by XSQL (redo %d)\n\"%s\"", xsql_error_retry,
		err_msg );
	if ( NULL != xsql_current_database_name && YES == xsql_error_loosen )
		{loosen = YES;
		dbname = duplicate_string( xsql_current_database_name );
		dbopt = duplicate_string( xsql_current_database_options );
		retry = xsql_error_retry;
		aside( "XSQL temporarily disconnecting from %s", dbname );
		xsql_end( dbname );	/* DIS-CONNECT TO RESOLVE DEADLOCK */
		}
	else
		{loosen = NO;		/* REMAIN ATTACHED TO DATABASE */
		}
	do
		{clock_set_now( &cnow );	/* WAIT BEFORE RETURNING */
		}
		while ( clock_second( cl ) == clock_second( &cnow ) );
	if ( YES == loosen )
		{aside( "XSQL re-connecting to %s", dbname );
		xsql_error_retry = xsql_error_retry_default;
		xsql_init_main( dbname, dbopt );
		xsql_error_retry = retry;
		xfree( dbname );
		xfree( dbopt );
		}
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
					/* REPORT ERROR FLAG SET BY SQL */
static void xsql_error_sql( void )
{	CLOCK	eclock;
  char error_msg[2000];
/* # line 102 "xsql.sc" */	/* inquire_sql */
  {
    IILQisInqSqlio((short *)0,1,32,1999,error_msg,63);
  }
/* # line 103 "xsql.sc" */	/* host code */
	clock_set_now( &eclock );
	aside( "XSQL problem at %d:%2.2d:%2.2d, sqlca.sqlcode = %ld",
		clock_hour( &eclock ), clock_minute( &eclock ),
		clock_second( &eclock ), (long) sqlca.sqlcode );
	xsql_error_status = 1;
	if ( --xsql_error_retry >= 0 )
		{xsql_problem( error_msg, &eclock );
		}
	else
		{xsql_error( error_msg );
		}
	xsql_error_status = 1;
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
						/* CHECK ACCESS IS OKAY */
static void xsql_check_sqlcode( char *text, char *item )
{	if ( 0 == sqlca.sqlcode )
		{return;
		}
	aside( text, item );
	xsql_error_sql();
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
					/* SET NUMBER RETRIES TO ATTEMPT  */
static void xsql_persistence( int attempts, int allow_loosen )
{	if ( attempts < 0 || attempts > 10000 )
		{inform( "xsql_persistence, INVALID attempts=%d IGNORED",
			attempts );
		}
	else
		{xsql_error_retry_default = attempts;
		xsql_error_loosen = ( YES == allow_loosen ) ? YES : NO;
		}
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
						/* SET FAILURE BEHAVIOUR */
static void xsql_softfail( int failmode )
{	xsql_error_softfail = ( 0 == failmode ) ? NO : YES;
}
/*---------------------------------------------------------------------------*/
					/* INITIALIZE DATABASE OPERATIONS */
int xsql_init_main( char *db_name, char *access_options )
{
  char database[50], acc_opt[50];
	if ( NULL != xsql_current_database_name )
		{bug( "attempt to open two databases\nold = %s\nnew = %s",
			xsql_current_database_name, db_name );
		exit( 0 );
		}
	xsql_error_status = 0;
	xsql_error_retry = xsql_error_retry_default;
	strcpy( database, db_name );
	strcpy( acc_opt, access_options );
/* # line 159 "xsql.sc" */	/* host code */
	do
		{xsql_error_status = 0;
		if ( EOS == acc_opt[0] )
			{
/* # line 163 "xsql.sc" */	/* connect */
  {
    IIsqInit(&sqlca);
    IIsqConnect(0,database,(char *)0, (char *)0, (char *)0, (char *)0, 
    (char *)0, (char *)0, (char *)0, (char *)0, (char *)0, (char *)0, 
    (char *)0, (char *)0, (char *)0);
    if (sqlca.sqlcode < 0) 
      xsql_error_sql();
  }
/* # line 164 "xsql.sc" */	/* host code */
			}
		else
			{
/* # line 167 "xsql.sc" */	/* connect */
  {
    IIsqInit(&sqlca);
    IIsqConnect(0,database,acc_opt,(char *)0, (char *)0, (char *)0, 
    (char *)0, (char *)0, (char *)0, (char *)0, (char *)0, (char *)0, 
    (char *)0, (char *)0, (char *)0);
    if (sqlca.sqlcode < 0) 
      xsql_error_sql();
  }
/* # line 168 "xsql.sc" */	/* host code */
			}
		}
		while ( xsql_error_status > 0 && xsql_error_retry >= 0 );
	if ( 0 == xsql_error_status )
		{xsql_current_database_name    = duplicate_string( db_name );
		xsql_current_database_options = duplicate_string( acc_opt );
		aside( "Opened database \"%s\"  options=\"%s\"",
			xsql_current_database_name, acc_opt );
		}
	else
		{aside( "FAILED to open database \"%s\"  options=\"%s\"",
			db_name, acc_opt );
		}
	return( xsql_error_status );
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
					/* INITIALIZE DATABASE OPERATIONS */
int xsql_init( char *dbname )
{	return( xsql_init_main( dbname, "+w" ) );
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
			/* INITIALIZE DATABASE OPERATIONS AND TAKE LOCK */
int xsql_init_exclusive( char *dbname )
{	return( xsql_init_main( dbname, "-l +w" ) );
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
					/* TERMINATE DATABASE OPERATIONS */
void xsql_end( char *db_name )
{	if ( NULL == xsql_current_database_name )
		{bug(
		"xsql_end: attempt to close database \"%s\" when not open",
			db_name );
		exit( 0 );
		}
	aside( "Closing database \"%s\"", db_name );
/* # line 203 "xsql.sc" */	/* commit */
  {
    IIsqInit(&sqlca);
    IIxact(3);
    if (sqlca.sqlcode < 0) 
      xsql_error_sql();
  }
/* # line 204 "xsql.sc" */	/* disconnect */
  {
    IIsqInit(&sqlca);
    IIsqDisconnect();
    if (sqlca.sqlcode < 0) 
      xsql_error_sql();
  }
/* # line 205 "xsql.sc" */	/* host code */
	xfree( xsql_current_database_name );
	xfree( xsql_current_database_options );
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
	/* BRIEFLY DISCONNECT THEN RECONNECT TO ALLOW OTHER PROCESSES ACCESS */
void xsql_polite( void )
{	char	*nam;
	if ( NULL == xsql_current_database_name )
		{bug( "xsql_polite: no database currently connected" );
		}
	nam = duplicate_string( xsql_current_database_name );
	xsql_end( nam );
	xsql_init( nam );
	xfree( nam );	
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
						/* SEND A COMMIT COMMAND */
void xsql_commit( void )
{
/* # line 224 "xsql.sc" */	/* commit */
  {
    IIsqInit(&sqlca);
    IIxact(3);
    if (sqlca.sqlcode < 0) 
      xsql_error_sql();
  }
/* # line 225 "xsql.sc" */	/* host code */
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
				/* EXECUTE DYNAMIC COMMAND - NO COMMIT */
int xsql_exec_lazy( char *cmd )
{
  char *comm;
	comm = cmd;
	xsql_error_retry = xsql_error_retry_default;
	do
		{xsql_error_status = 0;
/* # line 237 "xsql.sc" */	/* execute */
  {
    IIsqInit(&sqlca);
    IIsqExImmed(comm);
    IIsyncup((char *)0,0);
    if (sqlca.sqlcode < 0) 
      xsql_error_sql();
  }
/* # line 238 "xsql.sc" */	/* host code */
		}
		while ( xsql_error_status > 0 && xsql_error_retry >= 0 );
	return( xsql_error_status );
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
				/* EXECUTE DYNAMIC COMMAND - WITH COMMIT */
int xsql_exec( char *cmd )
{	int	ret_val;
	ret_val = xsql_exec_lazy( cmd );
	xsql_commit();
	return( ret_val );
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
						/* EXECUTE DYNAMIC PROCEDURE */
int xsql_exproc( char *cmd, int *return_value )
{
  int ret_val;
  char *proc;
	proc = cmd;			/* MUST NOT HAVE LEADING BLANKS */
	ret_val = *return_value;
	xsql_error_retry = xsql_error_retry_default;
	do
		{xsql_error_status = 0;
/* # line 263 "xsql.sc" */	/* execute procedure */
  {
    IIsqInit(&sqlca);
    IILQpriProcInit(2,proc);
    while (IILQprsProcStatus() != 0) {
      if (sqlca.sqlcode < 0) 
        xsql_error_sql();
    } /* IILQprsProcStatus */
    IIeqiqio((short *)0,1,30,4,&ret_val,"iiret");
  }
/* # line 264 "xsql.sc" */	/* host code */
		}
		while ( xsql_error_status > 0 && xsql_error_retry >= 0 );
	*return_value = ret_val;
	return( xsql_error_status );
}
/*---------------------------------------------------------------------------*/
			/* DEFAULT RETURN VALUE FOR NULLS IN INTEGER FIELDS */
void xsql_nullreturn_int( int retval )
{	xsql_dyn_null_handler_int = YES;
	xsql_dyn_null_default_int = retval;
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
			/* DEFAULT RETURN VALUE FOR NULLS IN REAL FIELDS */
void xsql_nullreturn_real( double retval )
{	xsql_dyn_null_handler_real = YES;
	xsql_dyn_null_default_real = retval;
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
			/* DEFAULT RETURN VALUE FOR NULLS IN STRING FIELDS */
void xsql_nullreturn_string( char *retval )
{	xsql_dyn_null_handler_string = YES;
	if ( NULL == retval )
		{bug( "xsql_nullreturn_string, NULL input string" );
		exit( 0 );
		}
	if ( NULL != xsql_dyn_null_default_string )
		{xfree( xsql_dyn_null_default_string );
		}
	xsql_dyn_null_default_string = duplicate_string( retval );
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
		/* DEFAULT RETURN VALUE FOR NULLS IN DATE AND TIME FIELDS */
void xsql_nullreturn_datetime( TIME *retval )
{	xsql_dyn_null_handler_datetime = YES;
	if ( NULL == retval )
		{bug( "xsql_nullreturn_datetime, NULL input TIME" );
		exit( 0 );
		}
	time_copy( &xsql_dyn_null_default_datetime, retval );
}
/*---------------------------------------------------------------------------*/
				/* RETURN POINTER TO INGRES SQL DATA AREA */
IISQLDA *xsql_dyn_iisqlda( XSQL_DYN *xd )
{	return( &(xd->idesc) );
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
	/* EXTRACT CONTENTS OF INGRES STRUCTURE INTO MORE USABLE C STRUCTURE */
void xsql_dyn_init_field( IISQLVAR *sv, XSQL_DYN_FIELD *dv )
{	char	*err_msg;
	dv->name = (char *) xmalloc( (int) sv->sqlname.sqlnamel + 3 );
	sprintf( dv->name, "%*.*s", (int) sv->sqlname.sqlnamel,
		(int) sv->sqlname.sqlnamel, sv->sqlname.sqlnamec );
	dv->ntype = 0;
	dv->typ = "ERROR";
	dv->length = (int) sv->sqllen;
	dv->nullable = ( sv->sqltype < 0 ) ? YES : NO;
	switch( abs( (int) sv->sqltype ) )
		{
		case IISQ_DTE_TYPE:
			dv->typ = "Date - Output";
			dv->ntype = DYNA_TYPE_DATE;
			break;
		case IISQ_MNY_TYPE:
			dv->typ = "Money - Output";
			break;
		case IISQ_DEC_TYPE:
			dv->typ = "Decimal - Output";
			break;
		case IISQ_CHA_TYPE:	/* LOGICAL KEYS RETURN AS THIS */
			dv->typ = "Char - Input, Output";
			dv->ntype = DYNA_TYPE_FIXCHAR;
			break;
		case IISQ_VCH_TYPE:
			dv->typ = "Varchar - Input, Output";
			dv->ntype = DYNA_TYPE_STRING;
			break;
		case IISQ_INT_TYPE:
			dv->typ = "Integer - Input, Output";
			dv->ntype = DYNA_TYPE_INT;
			break;
		case IISQ_FLT_TYPE:
			dv->typ = "Float - Input, Output";
			dv->ntype = DYNA_TYPE_REAL;
			break;
		case IISQ_CHR_TYPE:
			dv->typ = "C - Not seen";
			break;
		case IISQ_TXT_TYPE:
			dv->typ = "Text - Not seen";
			break;
		case IISQ_TBL_TYPE : 
			dv->typ = "Table field - Output";
			break;
		case IISQ_DTE_LEN:
			dv->typ = "Date length";
			break;
		default:
			err_msg = (char *) xmalloc( 30 );
			sprintf( err_msg, "UNKNOWN=%d", (int) sv->sqltype );
			dv->typ = err_msg;
			error( err_msg );
			break;
		}			
	sv->sqldata = NULL;
	switch( dv->ntype )
		{case DYNA_TYPE_INT:
			sv->sqldata = (char *) &(dv->val.i);
			if ( YES == dv->nullable )
				{if ( YES != xsql_dyn_null_handler_int )
					{bug(
		"xsql: no default return value defined for NULL integer fields"
		"\ncall xsql_nullreturn_int() before running this query"
						);
					exit( 0 );
					}
				dv->def.i = xsql_dyn_null_default_int;
				}
			break;
		case DYNA_TYPE_REAL:
			sv->sqldata = (char *) &(dv->val.r);
			if ( YES == dv->nullable )
				{if ( YES != xsql_dyn_null_handler_real )
					{bug(
		"xsql: no default return value defined for NULL real fields"
		"\ncall xsql_nullreturn_real() before running this query"
						);
					exit( 0 );
					}
				dv->def.r = xsql_dyn_null_default_real;
				}
			break;
		case DYNA_TYPE_DATE:
			sv->sqldata = dv->val.s = (char *) xmalloc(
				IISQ_DTE_LEN + 40 );
			if ( YES == dv->nullable )
				{if ( YES != xsql_dyn_null_handler_datetime )
					{bug(
			"xsql: no return value defined for date/time fields" );
					exit( 0 );
					}
				time_copy( &(dv->def.t),
					&xsql_dyn_null_default_datetime );
				}
			break;
		case DYNA_TYPE_FIXCHAR:
			sv->sqldata = dv->val.s = (char *) xmalloc(
				(int) sv->sqllen + 10 );
			if ( YES == dv->nullable )
				{if ( YES != xsql_dyn_null_handler_string )
					{bug(
			"xsql: no return value defined for string fields" );
					exit( 0 );
					}
				dv->def.s = (char *) xmalloc(
					(int) sv->sqllen + 10 );
				sprintf( dv->def.s, "%-*.*s",
					sv->sqllen, sv->sqllen,
					( NULL != xsql_dyn_null_default_string)
					? xsql_dyn_null_default_string
					: "BOLLOCKS!" );
				}
			break;
		case DYNA_TYPE_STRING:
			sv->sqldata = dv->val.s = (char *) xmalloc(
				(int) sv->sqllen + 4 );
			if ( YES == dv->nullable )
				{if ( YES != xsql_dyn_null_handler_string )
					{bug(
			"xsql: no return value defined for string fields" );
					exit( 0 );
					}
				dv->def.s = duplicate_string(
					( NULL != xsql_dyn_null_default_string)
					? xsql_dyn_null_default_string
					: "XSQL-NO-DEFAULT" );
				}
			break;
		case 0:
			bug( "xsql_dyn_init_field, unsupported type" );
			break;
		default:
			break;
		}
	sv->sqlind = &(dv->indicator);
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
				/* PREPARE QUERY AND TRANSLATION STRUCTURES */
XSQL_DYN *xsql_dyn_init( char *dyna_id, char *dyna_query_string )
{	int	i;
	static	long	query_id = 0;
	IISQLDA		*da_ptr;
	XSQL_DYN	*d;
  char *dyn_word, *sel_cmd;
	d = (XSQL_DYN *) xmalloc( sizeof(XSQL_DYN) );
	d->dyn_id = dyn_word = duplicate_string( dyna_id );
	d->sel_cmd = sel_cmd = duplicate_string( dyna_query_string );
	sprintf( d->cur_id, "xd%dcur", query_id++ );
	d->cur_ok = NO;
	d->idesc.sqln = IISQ_MAX_COLS;
	da_ptr = &(d->idesc);
/* # line 466 "xsql.sc" */	/* prepare */
  {
    IIsqInit(&sqlca);
    IIsqPrepare(0,dyn_word,da_ptr,0,sel_cmd);
    if (sqlca.sqlcode < 0) 
      xsql_error_sql();
  }
/* # line 467 "xsql.sc" */	/* host code */
	d->nfield = (int) d->idesc.sqld;
	d->field = (XSQL_DYN_FIELD *) xmalloc( d->nfield
		* sizeof(XSQL_DYN_FIELD) );
	for ( i = 0; i < d->nfield; i++ )
		{xsql_dyn_init_field( d->idesc.sqlvar + i, d->field + i );
		}
	return( d );
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
			/* FREE STORAGE USED BY DYNAMIC STRUCTURE FIELD */
void xsql_dyn_end_field( XSQL_DYN_FIELD *xdf )
{
	xfree( xdf->name );
	if ( DYNA_TYPE_STRING == xdf->ntype || DYNA_TYPE_FIXCHAR == xdf->ntype
			|| DYNA_TYPE_DATE == xdf->ntype )
		{xfree( xdf->val.s );
		if ( YES == xdf->nullable &&
				( DYNA_TYPE_STRING == xdf->ntype
				|| DYNA_TYPE_FIXCHAR == xdf->ntype ) )
			{xfree( xdf->def.s );
			}
		}
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
				/* FREE STORAGE USED BY DYNAMIC STRUCTURE */
void xsql_dyn_end( XSQL_DYN *xd )
{	int	i;
	for ( i = 0; i < xd->nfield; i++ )
		{xsql_dyn_end_field( xd->field + i );
		}
	xfree( xd->field );
	xfree( xd->dyn_id );
	xfree( xd->sel_cmd );
	xfree( xd );
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
					/* DECLARE AND OPEN A DYNAMIC CURSOR */
void xsql_dyn_cursor_init( XSQL_DYN *xd, char *access_mode )
{
  char *query_name, *cursor_name;
	cursor_name = xd->cur_id;
	query_name = xd->dyn_id;
/* # line 512 "xsql.sc" */	/* host code */
	do
		{xsql_error_status = 0;
		if ( NULL == access_mode || EOS == access_mode[0] )
			{
/* # line 516 "xsql.sc" */	/* open */
  {
    IIsqInit(&sqlca);
    IIcsOpen(cursor_name,0,0);
    IIwritio(1,(short *)0,1,32,0,query_name);
    IIcsQuery(cursor_name,0,0);
    if (sqlca.sqlcode < 0) 
      xsql_error_sql();
  }
/* # line 517 "xsql.sc" */	/* host code */
			}
		else if ( 0 == strcmp_nocase( access_mode, "r" ) )
			{
/* # line 520 "xsql.sc" */	/* open */
  {
    IIsqInit(&sqlca);
    IIcsOpen(cursor_name,0,0);
    IIwritio(1,(short *)0,1,32,0,query_name);
    IIwritio(0,(short *)0,1,32,0," for readonly ");
    IIcsQuery(cursor_name,0,0);
    if (sqlca.sqlcode < 0) 
      xsql_error_sql();
  }
/* # line 521 "xsql.sc" */	/* host code */
			}
		else
			{bug( "xsql_dyn_cursor_init, bad access_mode \"%s\"",
				access_mode );
			}
		}
		while ( xsql_error_status > 0 && xsql_error_retry >= 0 );
	xd->cur_ok = ( 0 == xsql_error_status ) ? YES : NO;
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
					/* CLOSE A DYNAMIC CURSOR */
void xsql_dyn_cursor_end( XSQL_DYN *xd )
{
  char *cursor_name;
	cursor_name = xd->cur_id;
/* # line 538 "xsql.sc" */	/* close */
  {
    IIsqInit(&sqlca);
    IIcsClose(cursor_name,0,0);
    if (sqlca.sqlcode < 0) 
      xsql_error_sql();
  }
/* # line 539 "xsql.sc" */	/* host code */
	xd->cur_ok = NO;
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
					/* FETCH DATA INTO CURSOR */
int xsql_query_fetch( XSQL_DYN *xd )
{
	IISQLDA	*desc;
  char *cursor_name;
	if ( xd->cur_ok != YES )
		{
		if ( xsql_error_softfail != YES )
			{
			bug(
		"xsql_query_fetch, cursor undefined or failed to open" );
			exit( 0 );
			}
		aside( "xsql_query_fetch, cursor undefined or failed to open" );
		return( 2 );
		}
	cursor_name = xd->cur_id;
	desc = &(xd->idesc);
/* # line 562 "xsql.sc" */	/* fetch */
  {
    IIsqInit(&sqlca);
    if (IIcsRetrieve(cursor_name,0,0) != 0) {
      IIcsDaGet(0,desc);
      IIcsERetrieve();
    } /* IIcsRetrieve */
    if (sqlca.sqlcode < 0) 
      xsql_error_sql();
  }
/* # line 563 "xsql.sc" */	/* host code */
	return( ( 0 == sqlca.sqlcode ) ? 0 : 1 );
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
		/* INITIALIZE DATA-STRUCTURE AND CURSOR SIMULTANEOUSLY */
XSQL_DYN *xsql_query_open( char *dyn_id, char *query_string, char *acmod )
{	XSQL_DYN	*df;
	df = xsql_dyn_init( dyn_id, query_string );
	xsql_dyn_cursor_init( df, acmod );
	if ( df->cur_ok != YES )
		{aside( "xsql_query_open, failed - returning NULL" );
		xsql_query_close( df );
		return( NULL );
		}
	return( df );
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
		/* INITIALIZE DATA-STRUCTURE AND CURSOR SIMULTANEOUSLY */
XSQL_DYN *xsql_query_new( char *query_string )
{	return( xsql_query_open( "xsql_q_n", query_string, "r" ) );
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
		/* TERMINATE DATA-STRUCTURE AND CURSOR SIMULTANEOUSLY */
void xsql_query_close( XSQL_DYN *df )
{	xsql_dyn_cursor_end( df );
	xsql_dyn_end( df );
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
						/* EXECUTE DYNAMIC COMMAND */
int xsql_dyn_execute( XSQL_DYN *xd, char *cmd )
{
	IISQLDA	*desc;
  char *comman;
  char *cursor_name;
  char *query_name;
  char s[500];
	inform( "execute \"%s\"", cmd );
	bug( "xsql_dyn_execute, total mess, manual is crap - not written" );
	exit( 0 );
	desc = &(xd->idesc);
	comman = cmd;
	query_name = xd->dyn_id;
/* # line 609 "xsql.sc" */	/* prepare */
  {
    IIsqInit(&sqlca);
    IIsqPrepare(0,"oneoff",(char *)0,0,comman);
    if (sqlca.sqlcode < 0) 
      xsql_error_sql();
  }
/* # line 610 "xsql.sc" */	/* execute */
  {
    IIsqInit(&sqlca);
    IIsqExStmt("oneoff",0);
    IIsqDaIn(0,query_name);
    IIsyncup((char *)0,0);
    if (sqlca.sqlcode < 0) 
      xsql_error_sql();
  }
/* # line 612 "xsql.sc" */	/* host code */
	inform( "execute - done %d", sqlca.sqlcode );
	return( ( 0 == sqlca.sqlcode ) ? 0 : 1 );
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
					/* RETURN NUMBER OF FIELDS SELECTED */
int xsql_dyn_nfields( XSQL_DYN *xd )
{	return( xd->nfield );
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
						/* RETURN NAME OF FIELD */
char *xsql_dyn_field_name( XSQL_DYN *xd, int indx )
{	return( xd->field[indx].name );
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
						/* RETURN LENGTH OF FIELD */
int xsql_dyn_field_length( XSQL_DYN *xd, int indx )
{	return( xd->field[indx].length );
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
				/* RETURN INTEGER CODE FOR FIELD TYPE */
int xsql_dyn_field_type( XSQL_DYN *xd, int indx )
{	return( xd->field[indx].ntype );
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
				/* RETURN TEXT DESCRIPTION OF FIELD */
char *xsql_dyn_field_description( XSQL_DYN *xd, int indx )
{	return( xd->field[indx].typ );
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
					/* EXTRACT AND PROCESS TIME VALUE */
/*
 N.B. IF DATE IS ABSOLUTE THEN DMY SEEMS ALWAYS PRESENT, EVEN IF FLAG=33 (WHICH
      IT IS SET TO IF THE DATE IS INSERTED AS `NOW') - GRRR....
      SOMETIMES SECS ARE < 0, AM ASSUMING THIS IS AN ALTERNATE WAY OF
      STORING TIME-SHIFT (BST->GMT) WITHOUT WRAPPING DAY VALUE
*/
void *xsql_dyn_extract_time( XSQL_DYN_FIELD_VAR *xv )
{
	int	sc;		/* CLOCK IS MSEC AFTER MIDNIGHT */
	int	convert_normal = 1;
	int	*it;
	short	*st;
	char *tf;
	TIME	*tm;
	tm = (TIME *) &xv->t;
	tf = (char *) xv->s;			/* FLAG IN BYTE 0 */
	st = (short *) xv->s;			/* DMY  IN BYTE 1,2,3 */
	it = (int *) xv->s;	    		/* MSEC IN BYTES 4+5 */
	sc = it[2] / 1000;
	tm->contents = 0;
	if ( ( *tf & XSQL_DATETIME_BIT_ABSOLUTE )
			|| ( *tf & XSQL_DATETIME_BIT_YEAR ) )
		{tm->contents |= XTIME_DATE_SET;
		date_set( &(tm->date),
			(int) st[3],			/* DAY    */
			(int) st[2],			/* MONTH  */
			(int) st[1] );			/* YEAR	  */
		}
	else
		{date_set( &(tm->date), 1, 1, 1880 );
		}
	if ( *tf & XSQL_DATETIME_BIT_TIME )
		{tm->contents |= XTIME_CLOCK_SET;
		if ( sc < 0 )
			{sc += 3600;
			convert_normal = 0;
			}
		clock_set( &(tm->clock),
			sc / 3600,			/* HOUR   */
			( sc / 60 ) % 60,		/* MINUTE */
			sc % 60 );			/* SECOND */
		if ( xsql_returnlocaltime && convert_normal )
			{time_gmt_to_local( tm );
			}	/* INGRES ALWAYS STORES GMT INTERNALLY */
		}
	else
		{clock_set( &(tm->clock), 0, 0, 0 );
		}
	return( (void *) tm );
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
		/* RETURN POINTER TO APPROPRIATE VARIABLE HOLDING VALUE */
void *xsql_dyn_field_get( XSQL_DYN *xd, int indx )
{
	short	*slen;
	XSQL_DYN_FIELD	*xdf;
	XSQL_DYN_FIELD_VAR	*xv;
	if ( indx < 0 || indx >= xd->nfield )
		{bug(
	"xsql_dyn_field_get, invalid field index = %d (range is 0 - %d",
			indx, xd->nfield - 1 );
		}
	xdf = xd->field + indx;
	if ( NO == xdf->nullable || 0 == xdf->indicator )
		{xv = &(xdf->val);
		switch( xdf->ntype )
			{case DYNA_TYPE_INT:
				if ( xdf->length < 4 )	/* MASK FOR SHORTS */
					{xv->i &= 0xFFFF;
					}
				return( (void *) &(xv->i) );
				break;
			case DYNA_TYPE_REAL:
				return( (void *) &(xv->r) );
				break;
			case DYNA_TYPE_DATE:
				return( xsql_dyn_extract_time( xv ) );
				break;
			case DYNA_TYPE_STRING:
				slen = (short *) xv->s;
				xv->s[ 2 + (int) *slen ] = EOS;
				return( (void *) ( xv->s + 2 ) );
				break;
			case DYNA_TYPE_FIXCHAR:
				return( (void *) xv->s );
				break;
			default:
				break;
			}
		}
	else					/* NULL VALUE IN FIELD */
		{xv = &(xdf->def);
		switch( xdf->ntype )
			{case DYNA_TYPE_INT:
				return( (void *) &(xv->i) );
				break;
			case DYNA_TYPE_REAL:
				return( (void *) &(xv->r) );
				break;
			case DYNA_TYPE_DATE:
				return( (void *) &(xv->t) );
				break;
			case DYNA_TYPE_STRING:
			case DYNA_TYPE_FIXCHAR:
				return( (void *) xv->s );
				break;
			default:
				break;
			}
		}
	bug( "xsql_dyn_field_get, field ntype %d", xdf->ntype );
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
				/* FILL STRING WITH VALUE OF ANY TYPE */
void xsql_get_string( XSQL_DYN *xd, int indx, char *out )
{	int	i;
	long	*lp;
	double	*rp;
	char	*sp;
	TIME	*tp;
	void	*result;
	XSQL_DYN_FIELD	*xdf;
	xdf = xd->field + indx;
	result = xsql_dyn_field_get( xd, indx );
	switch( xdf->ntype )
		{case DYNA_TYPE_INT:
			lp = (long *) result;
			sprintf( out, "%ld", *lp );
			break;
		case DYNA_TYPE_REAL:
			rp = (double *) result;
			sprintf( out, "%lg", *rp );
			break;
		case DYNA_TYPE_DATE:
			tp = (TIME *) result;
			if ( tp->contents & XTIME_DATE_SET )
				{if ( tp->contents & XTIME_CLOCK_SET )
					{time_to_string( out, tp, 0, NULL, 1 );
					}
				else
					{date_to_string( out, &(tp->date), 0 );
					}
				}
			else
				{clock_to_string( out, &(tp->clock), 1 );
				}
			break;
		case DYNA_TYPE_STRING:
			sp = (char *) result;
			strcpy( out, sp );
			break;
		case DYNA_TYPE_FIXCHAR:
			sp = (char *) result;
			for ( i = 0; i < xdf->length; i++ )
				{out[i] = sp[i];
				}
			out[ xdf->length ] = EOS;
			break;
		default:
			bug( "xsql_dyn_field_get_string, field ntype %d",
				(int) xdf->ntype );
			exit( 0 );
			break;
		}
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
					/* FILL DATE WITH FIELD VALUE */
void xsql_get_date( XSQL_DYN *xd, int indx, DATE *dt )
{	TIME	*tp;
	void	*result;
	if ( DYNA_TYPE_DATE != xd->field[indx].ntype )
		{bug( "xsql_dyn_field_get_date" );
		exit( 0 );
		}
	result = xsql_dyn_field_get( xd, indx );
	tp = (TIME *) result;
	date_copy( dt, &(tp->date) );
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
					/* FILL TIME WITH FIELD VALUE */
void xsql_get_time( XSQL_DYN *xd, int indx, TIME *t )
{	TIME	*tp;
	void	*result;
	if ( DYNA_TYPE_DATE != xd->field[indx].ntype )
		{bug( "xsql_dyn_field_get_time" );
		exit( 0 );
		}
	result = xsql_dyn_field_get( xd, indx );
	tp = (TIME *) result;
	time_copy( t, tp );
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
					/* RETURN VALUE OF INTEGER FIELDS */
long xsql_get_int( XSQL_DYN *xd, int indx )
{	long	*lp;
	void	*result;
	if ( DYNA_TYPE_INT != xd->field[indx].ntype )
		{bug( "xsql_dyn_field_get_int, wrong type" );
		exit( 0 );
		}	
	result = xsql_dyn_field_get( xd, indx );
	lp = (long *) result;
	return( *lp );
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
					/* RETURN VALUE OF INTEGER FIELDS */
double xsql_get_real( XSQL_DYN *xd, int indx )
{	double	*rp;
	void	*result;
	if ( DYNA_TYPE_REAL != xd->field[indx].ntype )
		{bug( "xsql_dyn_field_get_real, wrong type" );
		exit( 0 );
		}	
	result = xsql_dyn_field_get( xd, indx );
	rp = (double *) result;
	return( *rp );
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
			/* RETURN INDEX OF A FIELD WITH A PARTICULAR NAME */
int xsql_indexof( XSQL_DYN *x, char *name )
{
        int     n;
        n = xsql_dyn_nfields( x );
        while ( --n >= 0 )
                {if ( 0 == strcmp_nocase( name,
                                xsql_dyn_field_name( x, n ) ) )
                        {return( n );
                        }
                }
        return( -1 );
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
		/* INSERT VALUE INTO SQL STRUCTURE PRIOR TO MODIFYING DB  */
void *xsql_dyn_field_put( XSQL_DYN *xd, int indx, void *val )
{	int	*ip;
	double	*rp;
	char	*sp;
	short	*slen, *st;
	DATE	*dt;
	XSQL_DYN_FIELD	*xdf;
	xdf = xd->field + indx;
	switch( xdf->ntype )
		{case DYNA_TYPE_INT:
			ip = (int *) val;
			xdf->val.i = (int) ( *ip );
			break;
		case DYNA_TYPE_REAL:
			rp = (double *) val;
			xdf->val.r = (double) ( *rp );
			break;
		case DYNA_TYPE_DATE:
			dt = (DATE *) val;
			st = (short *) xdf->val.s;
			st[1] = (short) date_year( dt );
			st[2] = (short) date_month( dt );
			st[3] = (short) date_day( dt );
			break;
		case DYNA_TYPE_STRING:
			sp = (char *) val;
			slen = (short *) xdf->val.s;
			*slen = (short) strlen( sp );
			strcpy( xdf->val.s + 2, sp ); 
			break;
		case DYNA_TYPE_FIXCHAR:
			return( (void *) xdf->val.s );
			break;		/* IGNORE */
		default:
			bug( "xsql_dyn_field_put, field ntype %d",
				(int) xdf->ntype );
			exit( 0 );
			break;
		}
	return( NULL );
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
	/* CONVERT STRING INTO APPROPRIATE TYPE AND INSERT INTO SQL STRUCTURE */
void xsql_dyn_field_put_string( XSQL_DYN *xd, int indx, char *in )
{	long	lp;
	double	rp;
	void	*putval;
	char	*msg;
	DATE	dp;
	XSQL_DYN_FIELD	*xdf;
	xdf = xd->field + indx;
	switch( xdf->ntype )
		{case DYNA_TYPE_INT:
			lp = (long) atoi( in );
			putval = (void *) &lp;
			break;
		case DYNA_TYPE_REAL:
			rp = (double) atof( in );
			putval = (void *) &rp;
			break;
		case DYNA_TYPE_DATE:
			string_to_date( in, &dp, &msg, YES );
			putval = (void *) &dp;
			break;
		case DYNA_TYPE_STRING:
			putval = (void *) in;
			break;
		case DYNA_TYPE_FIXCHAR:
			bug( "cannot insert logical key" );
			exit( 0 );
			break;
		default:
			bug( "xsql_dyn_field_put_string, field ntype %d",
				(int) xdf->ntype );
			exit( 0 );
			break;
		}
	xsql_dyn_field_put( xd, indx, putval );
}
/*---------------------------------------------------------------------------*/
				/* RETURN NUMBER OF ROWS IN A TABLE */
int xsql_count_rows( char *what, char *table_name, char *where )
{	int	nrows = -1;
	char	*selbuf;
	XSQL_DYN	*xr;
	selbuf = (char *) xmalloc( 100 + strlen( table_name )
		+ ( ( NULL != what  ) ? strlen( what  ) : 1 )
		+ ( ( NULL != where ) ? strlen( where ) : 1 ) );
	sprintf( selbuf, ( NULL != where )
		? "SELECT COUNT (%s) FROM %s WHERE %s"
		: "SELECT COUNT (%s) FROM %s",
		( NULL != what ) ? what : "*",
		table_name, where );
	xr = xsql_dyn_init_fetch( "cr", selbuf, "r" );
	while ( 0 == xsql_dyn_cursor_fetch( xr ) )
		{nrows = xsql_dyn_field_get_int( xr, 0 );
		}
	xsql_dyn_end_fetch( xr );
	xfree( selbuf );
	return( nrows );
}
/*---------------------------------------------------------------------------*/
		/* TRANSFORM SINGLE QUOTES INSIDE SQL STRING LITERALS */
void xsql_squote( char *out, char *in )
{	while ( EOS != *in )
		{if ( '\'' == *in )
			{*out++ = '\'';
			}
		*out++ = *in++;
		}
	*out = EOS;	/* USER-SUPPLIED `OUT' MUST BE LARGE ENOUGH */
}
/*---------------------------------------------------------------------------*/
void xsql_data_xstring_squote( XSTRING *st, char *sq )
{
	char *sbuf;
	sbuf = (char *) malloc( ( strlen( sq ) * 2 ) + 2);
	xsql_squote( sbuf, sq );
	xstring_add_char( st, '\'' );
	xstring_add_string( st, sbuf );
	xstring_add_char( st, '\'' );
	free( sbuf );
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
							/* INSERT SQL DATA */
int xsql_data_insert( XPAIR *pp, int loggit, char *table )
{
	int	i;
	int	errs = 0;
	char	buf[100];
	XPAIR_FIELD	*fld;
	XSTRING	*sql;
	sql = xstring_new();
	xstring_add_string( sql,"INSERT INTO " );
	xstring_add_string( sql, table );
	xstring_add_string( sql, " (" );
	for ( i = 0; i < pp->nfields; i++ )
		{
		if ( i > 0 )
			{xstring_add_char( sql, ',' );
			}
		xstring_add_string( sql, pp->field[i].name );
		}
	xstring_add_string( sql,") VALUES (" );
	for ( i = 0; i < pp->nfields; i++ )
		{
		if ( i > 0 )
			{xstring_add_char( sql, ',' );
			}
		fld = pp->field + i;
		switch( fld->type )
			{
			case XPAIR_TYPE_INT:
				xstring_add_int( sql, fld->val.i );
				break;
			case XPAIR_TYPE_REAL:
				sprintf( buf, "%.6lg", fld->val.r );
				xstring_add_string( sql, buf );
				break;
			case XPAIR_TYPE_TIME:
				xstring_add_char( sql, '\'' );
				xstring_add_time( sql, &(fld->val.t) );
				xstring_add_char( sql, '\'' );
				break;
			case XPAIR_TYPE_DATE:
				xstring_add_char( sql, '\'' );
				xstring_add_date( sql, &(fld->val.t.date) );
				xstring_add_char( sql, '\'' );
				break;
			case XPAIR_TYPE_STRING:
				xsql_data_xstring_squote( sql, fld->val.s );
				break;
			default:
				bug(
				"xsql_data_insert: field[%d] %s invalid type",
					i, fld->name );
				errs++;
				break;
			}
		}
	xstring_add_string( sql, ")" );
	if ( YES == loggit )
		{
		aside( "xsql_data_insert:\n%s", xstring_value( sql ) );
		}
	errs = xsql_execute_immediate( xstring_value( sql ) );
	xstring_delete( sql );
	return( errs );
}
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
							/* UPDATE SQL DATA */
int xsql_data_update( XPAIR *pp, int loggit, char *table, char *where )
{
	int	i;
	int	errs = 0;
	char	buf[100];
	XSTRING	*sql;
	XPAIR_FIELD	*fld;
	sql = xstring_new();
	xstring_add_string( sql, "UPDATE " );
	xstring_add_string( sql, table );
	xstring_add_string( sql, " SET " );
	for ( i = 0; i < pp->nfields; i++ )
		{
		fld = pp->field + i;
		if ( i > 0 )
			{xstring_add_char( sql, ',' );
			}
		xstring_add_string( sql, pp->field[i].name );
		xstring_add_char( sql, '=' );
		switch( fld->type )
			{
			case XPAIR_TYPE_INT:
				xstring_add_int( sql, fld->val.i );
				break;
			case XPAIR_TYPE_REAL:
				sprintf( buf, "%.6lg", fld->val.r );
				xstring_add_string( sql, buf );
				break;
			case XPAIR_TYPE_TIME:
				xstring_add_char( sql, '\'' );
				xstring_add_time( sql, &(fld->val.t) );
				xstring_add_char( sql, '\'' );
				break;
			case XPAIR_TYPE_DATE:
				xstring_add_char( sql, '\'' );
				xstring_add_date( sql, &(fld->val.t.date) );
				xstring_add_char( sql, '\'' );
				break;
			case XPAIR_TYPE_STRING:
				xsql_data_xstring_squote( sql, fld->val.s );
				break;
			default:
				bug( "xsql_data_update, invalid type" );
				errs++;
				break;
			}
		}
	if ( NULL != where )
		{
		xstring_add_string( sql, " WHERE " );
		xstring_add_string( sql, where );
		}
	if ( YES == loggit )
		{
		aside( "xsql_data_update:\n%s", xstring_value( sql ) );
		}
	errs = xsql_execute_immediate( xstring_value( sql ) );
	xstring_delete( sql );
	return( errs );
}
/*===========================================================================*/
#endif								/* XSQL.C */
